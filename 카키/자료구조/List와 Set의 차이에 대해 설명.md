> **순서와 중복 차이**
>

List는 입력 순서를 유지하며 데이터의 중복을 허용한다.

Set은 구현체에 따라 다른데

HashSet 구현체는 입력 순서를 보장하지 않으며, 데이터 중복을 허용하지 않는다.

LinkedHashSet은 입력 순서를 보장하며, 데이터 중복을 허용하지 않는다.

TreeSet은 데이터 타입의 기본 순서에 따라 정렬되거나, Comparator에 따라 정렬 기준을 정할 수 있고, 데이터 중복을 허용하지 않는다.

> 속도에 대한 차이
>

List는 임의의 요소에 대해 조회하거나 List 상태를 변경할 경우 List 요소들을 순회하기 때문에 O(n)의 시간복잡도를 갖는다.

반면 Set의 경우에는 해시 테이블 구조를 사용해 O(1) 시간 복잡도를 갖는다.

> **Set의 요소를 변경할 수 없는 이유**
>

요소가 수정되면 해시 값도 변경될 수 있어, 기존 저장 위치와 불일치가 발생할 수 있기 때문

또, 의도치 않게 중복된 값이 생길수도 있음

> **해시 테이블이란 ?**
>

키 - 값 쌍을 저장하는 자료구조로

키를 입력받아 해시 값으로 변경하가고 이 값을 인덱스로 사용해 빠른 연산이 가능하다.

> **Set이 순서를 보장하지 않는 이유**
>

저장 위치는 해시에 의해 결정된 다는 점과

Set의 크기가 커지면 내부적으로 리사이징이 발생하기 때문에 예측할 수가 없다.

또한 빠른 검색과 무결성에 최적화되어 있는데 순서를 유지하게 되면 추가적인 데이터 구조가 필요하기 때문에

본질에 초점을 맞췄다고 생각

> **Set이 리사이징을 하는 이유 ?**
>

요소가 많아질 수록 해시 충돌 가능성이 높아지고, 작다면 메모리 낭비를 초래하기 떄문
