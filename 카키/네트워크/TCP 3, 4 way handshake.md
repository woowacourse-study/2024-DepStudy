> **3-way handshake**
>

TCP 연결을 초기화할 때 사용한다.

Step 1: 연결을 원하는 쪽 → 연결 대상에게 SYN 패킷 전송 (연결 가능할까요?)

- ex:) 클라이언트가 서버에 연결 요청

Step 2: 연결 대상 → 연결을 원하는 쪽에게 SYN-ACK 패킷 전송 (네 ~ 연결 가능해요)

- ex:) 서버가 클라이언트의 요청을 수락하고 응답

Step 3: 연결을 원하는 쪽 → 연결 대상에게 ACK 패킷 전송 (네 그럼 연결할께요 ~)

- ex:) 클라이언트가 서버의 응답을 수신하고 응답

> **4-way handshake**
>

TCP 연결을 종료할 때 사용한다.

Step 1: 연결을 원하는 쪽 → 연결 대상에게 FIN 패킷 전송

- ex:) 클라이언트가 연결 종료를 요청

Step 2: 연결 대상 → 연결을 원하는 쪽에게 ACK 패킷 전송

- ex:) 서버가 종료 요청을 확인

Step 3: 연결 대상 → 연결을 원하는 쪽에게 데이터 전송을 마치고 FIN 패킷 전송

- ex:) 서버가 자신의 데이터 전송을 마치고 연결 종료를 알린다.

Step 4: 연결을 원하는 쪽 → 연결 대상에게 ACK 패킷 전송, 연결 대상은 ACK을 받고 연결을 종료

- ex:) 클라이언트가 서버의 연결 종료를 확인

이후 연결을 원하는 쪽은 TIME_WAIT 상태에 들어가고 일정 시간이 지나면 연결을 완전히 종료한다.

> **TIME_WAIT 상태가 있는 이유**
>

마지막으로 보내는 ACK 패킷의 유실이나 패킷의 지연 도착에 대비하기 위해 발생되는 상태이다.

만약 중간에 ACK 패킷이 유실되엇을 경우 요청을 받은 대상은 정상적인 연결 종료를 위해 FIN 패킷을 다시 보낸다.

이 때 연결을 요청한 쪽은 TIME_WAIT이기 때문에 FIN 패킷을 받아 다시 ACK 패킷을 전송할 수 있다.

따라서 신뢰성이 높은 통신이 가능해진다.

> **CLOSE_WAIT 상태**
>

FIN 을 받은 뒤 연결 종료가 완료되고 FIN 패킷을 보내기전 까지의 소켓 상태이다.

만약 소켓이 CLOSE_WAIT 상태로 계속 남아있다면

보통은 OS 또는 서버에 문제가 발생한 경우가 커 적절한 조치를 취해야 한다.
