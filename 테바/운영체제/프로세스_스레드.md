# 프로세스와 스레드의 차이

### 1. **기본 개념**
   - **프로세스**: 실행 중인 프로그램의 인스턴스를 말합니다. 프로세스는 자체적으로 독립된 메모리 공간(주소 공간)을 가지며, CPU 시간과 자원을 할당받아 실행됩니다.
   - **스레드**: 프로세스 내에서 실행되는 작은 작업 단위입니다. 스레드는 프로세스의 자원을 공유하면서 병렬로 실행됩니다.

### 2. **메모리 영역**
   - **프로세스**: 각 프로세스는 독립된 메모리 영역(코드, 데이터, 힙, 스택)을 가집니다. 프로세스 간에는 메모리를 공유하지 않기 때문에, 한 프로세스의 메모리 접근은 다른 프로세스에서 할 수 없습니다.
   - **스레드**: 같은 프로세스 내의 스레드들은 **코드, 데이터, 힙** 메모리 영역을 공유하지만, 각각의 **스택** 영역은 따로 가집니다. 이 덕분에 같은 프로세스 내 스레드들은 서로 자원에 쉽게 접근할 수 있습니다.

### 3. **자원 공유**
   - **프로세스**: 프로세스 간에는 자원을 공유하지 않으며, 서로 독립적으로 실행됩니다. 프로세스 간의 데이터 교환은 주로 **IPC(Inter-Process Communication)** 기술을 통해 이루어집니다.
   - **스레드**: 같은 프로세스 내에서는 자원(메모리, 파일, 네트워크 연결 등)을 공유합니다. 이로 인해 스레드 간의 **동기화** 문제가 발생할 수 있습니다.

### 4. **실행 단위**
   - **프로세스**: 운영체제는 프로세스를 독립된 실행 단위로 취급하여 스케줄링하고, 각 프로세스는 별도의 메모리 공간에서 실행됩니다.
   - **스레드**: 스레드는 프로세스 내에서 동시에 여러 작업을 수행할 수 있는 단위로, 한 프로세스 내에서 여러 스레드가 병렬로 실행될 수 있습니다.

### 5. **오버헤드**
   - **프로세스**: 새로운 프로세스를 생성할 때, 메모리 할당 및 자원 할당과 같은 작업으로 인해 상대적으로 많은 **오버헤드**가 발생합니다.
   - **스레드**: 스레드는 프로세스 내에서 자원을 공유하므로, 스레드를 생성하는 오버헤드는 상대적으로 작습니다.

### 6. **사용 예**
   - **프로세스**: 웹 브라우저, 텍스트 편집기와 같은 프로그램들은 각각 독립된 프로세스로 실행됩니다. 예를 들어, 구글 크롬은 각 탭을 별도의 프로세스로 실행합니다.
   - **스레드**: 다중 작업이 필요한 경우, 예를 들어, 웹 서버는 여러 요청을 처리하기 위해 스레드를 사용합니다. 각 요청은 별도의 스레드에서 병렬로 처리됩니다.

### 요약
- **프로세스**는 독립된 메모리 공간과 자원을 가지며, 서로 간의 영향을 받지 않음.
- **스레드**는 같은 프로세스 내에서 자원을 공유하며, 병렬 처리가 가능하지만 동기화가 필요함.

# 자바의 스레드와 OS 스레드 관계

**자바의 스레드와 OS 스레드**는 **JVM**이 운영체제와 상호작용하는 방식에 깊은 연관이 있습니다. 자바의 스레드는 **OS 스레드**를 기반으로 동작하는데, 이를 이해하려면 **자바 스레드 구현 방식**과 **운영체제 스레드 모델**을 알아야 합니다.

### 1. **자바 스레드 모델 (JVM 스레드)**
   - **자바 스레드**는 운영체제에 종속된 **네이티브 스레드**입니다. 즉, 자바에서 스레드를 생성하고 실행할 때, JVM은 운영체제의 스레드를 이용하여 자바 스레드를 구현합니다.
   - 대부분의 JVM 구현(HotSpot JVM 등)은 **운영체제 수준의 스레드**(native thread)와 직접적으로 매핑됩니다. 자바에서 `Thread` 클래스를 통해 스레드를 생성하면, JVM이 이를 **OS 스레드**로 변환하여 실행합니다.

### 2. **OS 스레드와의 관계**
   - 자바의 **멀티스레딩**은 운영체제의 **네이티브 스레드 모델**을 사용합니다. 자바 스레드는 운영체제의 스레드 스케줄러에 의해 관리됩니다. 운영체제가 자원을 할당하고, CPU에서 실행할 스레드를 스케줄링합니다.
   - 자바에서 `Thread.start()` 메서드를 호출하면, JVM이 운영체제에 스레드 생성을 요청하고, 해당 자바 스레드가 OS 스레드로 매핑되어 실행됩니다.
   - 운영체제 스레드가 자원을 많이 차지하기 때문에, 자바 스레드의 성능은 운영체제의 스레드 스케줄러에 크게 의존하게 됩니다.

### 3. **스레드 구현 방식**
   자바의 스레드 구현 방식은 **1:1 모델**로 설명될 수 있습니다.
   
   - **1:1 모델** (자바의 기본 방식)
     - 자바의 스레드는 **1:1 모델**로, 자바에서 생성한 각 스레드는 운영체제의 네이티브 스레드와 1:1로 매핑됩니다.
     - **장점**: 운영체제의 멀티스레드 기능을 활용할 수 있으며, 다중 CPU 환경에서 자바 스레드가 병렬로 실행됩니다.
     - **단점**: 스레드를 생성하는 데 비용이 많이 들 수 있고, 운영체제의 스레드 수 제한에 영향을 받습니다.

### 4. **JVM 스케줄링 및 운영체제 의존**
   - 자바 스레드는 JVM이 직접 스케줄링하지 않고, **운영체제의 스케줄러**에 의해 관리됩니다. 운영체제가 자원(CPU, 메모리 등)을 각 스레드에 할당하고, 우선순위를 설정하여 실행 시점을 결정합니다.
   - 즉, 자바 스레드가 CPU에서 실행되는 방식은 운영체제가 관리하므로, **OS에 따라 스레드 관리 및 성능**이 달라질 수 있습니다.

### 5. **자바 스레드의 라이브러리와 네이티브 스레드**
   - 자바는 `java.lang.Thread` 클래스를 통해 고수준 스레드 기능을 제공합니다. 하지만, 실제 스레드의 생성과 관리는 JVM 내부에서 운영체제의 **POSIX 스레드(pthread)** 같은 네이티브 스레드 라이브러리를 사용하여 처리됩니다.
   - 이러한 네이티브 스레드 라이브러리를 통해, 자바는 운영체제에 맞는 네이티브 스레드 API를 호출하고, 각 플랫폼에 맞게 스레드 실행을 지원합니다.

### 6. **자바의 경량 스레드 (Project Loom)**
   - 최근에는 자바에서 **경량 스레드** 개념을 도입한 **Project Loom**이 등장했습니다. 이 프로젝트는 기존의 OS 스레드 기반 자바 스레드를 보완하고, 많은 수의 스레드를 보다 효율적으로 관리하기 위한 경량 스레드를 제공합니다.
   - **Project Loom**은 기존의 OS 스레드를 사용하는 대신, **"가상 스레드"**라는 개념을 도입하여 많은 수의 스레드를 더 쉽게 생성하고 관리할 수 있게 합니다.

---

### 요약
- **자바의 스레드**는 운영체제의 **네이티브 스레드**와 1:1로 매핑됩니다. 자바에서 `Thread` 객체를 생성하면, JVM은 운영체제의 스레드 관리 시스템을 통해 자바 스레드를 운영체제 스레드로 실행합니다.
- **스레드 스케줄링** 및 **실행 관리**는 운영체제가 담당하며, 자바의 스레드 성능은 OS 스레드 모델과 스케줄러에 따라 달라질 수 있습니다.

# 스프링과 스레드
스프링 애플리케이션은 **스레드**를 활용하여 여러 작업을 동시에 처리할 수 있습니다. 특히 웹 애플리케이션에서는 여러 클라이언트의 요청을 처리하기 위해 멀티스레딩이 중요한 역할을 합니다. 아래는 **스프링 애플리케이션**과 **스레드**의 관계에 대한 주요 개념과 동작 원리입니다.

### 1. **기본적인 스레드 모델**
   - **싱글 스레드 모델** vs. **멀티 스레드 모델**: 
     스프링 애플리케이션은 기본적으로 **멀티스레드**로 동작합니다. 웹 서버(Tomcat, Jetty 등)나 스프링의 백그라운드 작업을 처리하는 컴포넌트는 **여러 스레드**를 생성하여 병렬로 작업을 처리합니다. 따라서 각 클라이언트 요청은 별도의 스레드에서 처리되며, 하나의 스레드가 요청을 처리하는 동안 다른 요청도 동시에 처리할 수 있습니다.
     
     스프링은 주로 **Tomcat**과 같은 서블릿 컨테이너를 사용하여 HTTP 요청을 처리하는데, 서블릿 컨테이너는 **스레드 풀(Thread Pool)**을 이용해 요청마다 새로운 스레드를 생성하거나 기존 스레드를 재사용합니다.

### 2. **서블릿 컨테이너와 스레드 풀**
   - **서블릿 컨테이너(Tomcat 등)**는 요청을 처리할 때, **스레드 풀**에서 스레드를 가져와 각각의 요청을 처리합니다. 각 HTTP 요청은 서블릿 컨테이너에 의해 새로운 스레드에서 처리됩니다.
   - **스레드 풀**은 애플리케이션 성능을 최적화하는 데 중요한 역할을 합니다. 요청 수가 많아질 경우, 스레드 풀이 없으면 매번 스레드를 새로 생성하고 삭제하는 데 시간이 많이 소요되지만, 스레드 풀은 스레드를 재사용하여 처리 성능을 높입니다.
   - 스프링 부트 애플리케이션은 내장된 **Tomcat**이나 **Jetty**를 사용하므로, 애플리케이션의 각 HTTP 요청은 **스레드 풀**에서 관리되는 **작업 스레드**를 통해 처리됩니다.

### 3. **비동기 작업 처리와 스레드**
   스프링은 **비동기 작업**이나 **백그라운드 작업**을 처리할 때도 스레드를 사용합니다. 대표적인 방법으로 **@Async** 어노테이션을 사용하여 비동기 작업을 수행할 수 있습니다.
   
   - **@Async**: 메서드에 이 어노테이션을 붙이면 해당 메서드는 별도의 스레드에서 비동기로 실행됩니다. 즉, 호출자는 해당 메서드가 끝날 때까지 기다리지 않고 바로 다음 작업을 수행할 수 있습니다.
   - **TaskExecutor**: 비동기 작업을 실행할 때 스레드를 관리하는 인터페이스로, 스프링에서 제공하는 **ThreadPoolTaskExecutor** 등을 사용하면 비동기 작업의 스레드를 효율적으로 관리할 수 있습니다.
     ```java
     @Async
     public void asyncMethod() {
         // 비동기 작업 수행
     }
     ```

### 4. **스레드 안전성(Thread Safety)**
   - 스프링 빈은 기본적으로 **싱글톤** 스코프로 동작하기 때문에, 여러 스레드에서 동시에 접근할 가능성이 있습니다. 이 경우, 특정 빈에 스레드 간의 **경합 조건(Race Condition)**이 발생할 수 있습니다.
   - **싱글톤 빈**은 스프링 애플리케이션 전반에 걸쳐 하나의 인스턴스만 공유되기 때문에, **상태를 유지하는 필드**를 가지는 경우 스레드 안전성을 고려해야 합니다. 필요한 경우 **synchronized** 키워드나 **ThreadLocal** 변수를 사용하여 동시성 문제를 해결할 수 있습니다.

### 5. **트랜잭션과 스레드**
   - 스프링의 **트랜잭션 관리**는 일반적으로 **스레드 바운드(Thread-bound)** 방식으로 동작합니다. 트랜잭션은 **스레드 로컬(ThreadLocal)** 변수에 저장되어 한 스레드 내에서만 유지됩니다.
   - 각 트랜잭션은 특정 스레드에서 시작되며, 그 스레드가 트랜잭션이 끝날 때까지 처리합니다. 다른 스레드로 트랜잭션을 넘길 수는 없으므로, 트랜잭션 경계를 넘지 않도록 스레드 안전성에 주의해야 합니다.

### 6. **Spring Boot와 WebFlux**
   - **Spring WebFlux**는 스프링의 **비동기 논블로킹 웹 프레임워크**로, 리액티브 프로그래밍을 기반으로 동작합니다. WebFlux는 스레드 풀과는 다른 방식으로 **이벤트 루프(Event Loop)**를 사용하여 요청을 처리합니다.
   - 이는 전통적인 스레드 기반의 **블로킹 I/O 모델** 대신, 적은 수의 스레드로 더 많은 요청을 처리할 수 있게 해줍니다. WebFlux는 **Netty**와 같은 논블로킹 I/O 기반의 서버와 잘 통합됩니다.

---

### 요약
- **스프링 애플리케이션**은 기본적으로 **멀티스레드 환경**에서 동작하며, HTTP 요청은 **서블릿 컨테이너**(예: Tomcat)의 **스레드 풀**을 통해 병렬로 처리됩니다.
- **비동기 작업**이나 **백그라운드 처리**는 스프링의 **@Async** 어노테이션과 **TaskExecutor**를 통해 별도의 스레드를 사용합니다.
- **싱글톤 빈**에 대한 동시성 문제를 피하기 위해 스레드 안전성을 고려해야 하며, 스프링의 **트랜잭션 관리**는 스레드 단위로 작동합니다.
- **Spring WebFlux**는 전통적인 스레드 모델 대신, 논블로킹 I/O와 **이벤트 루프**를 사용하여 더 적은 스레드로 더 많은 요청을 처리합니다.