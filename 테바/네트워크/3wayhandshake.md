# TCP 3, 4 way handshake에 대해서 설명해보세요

TCP(Transmission Control Protocol)는 신뢰성 있는 데이터 전송을 제공하는 프로토콜로, 연결을 설정하고 종료하는 과정에서 각각 3-way handshake와 4-way handshake를 사용합니다. 이 과정은 다음과 같습니다.

### TCP 3-Way Handshake

TCP의 연결 설정 과정인 3-way handshake는 클라이언트와 서버 간의 안정적인 연결을 구축하는 데 사용됩니다. 이 과정은 다음과 같은 단계로 이루어집니다:

1. **SYN (Synchronize)**: 
   - 클라이언트가 서버에 연결 요청을 보냅니다. 이 요청은 SYN 플래그가 설정된 TCP 세그먼트로, 클라이언트의 초기 순서 번호(Initial Sequence Number, ISN)를 포함합니다.
   - 예를 들어, 클라이언트가 ISN = 1000인 SYN 패킷을 서버에 보냅니다.

   ```
   클라이언트 --> 서버 : SYN, ISN = 1000
   ```

2. **SYN-ACK (Synchronize-Acknowledge)**:
   - 서버는 클라이언트의 SYN 패킷을 수신한 후, 연결 요청을 수락하는 응답을 보냅니다. 이 응답은 SYN과 ACK 플래그가 모두 설정된 TCP 세그먼트로, 서버의 초기 순서 번호(예: ISN = 2000)와 클라이언트의 ISN에 대한 ACK 번호(1001)를 포함합니다.
   
   ```
   서버 --> 클라이언트 : SYN-ACK, ISN = 2000, ACK = 1001
   ```

3. **ACK (Acknowledge)**:
   - 클라이언트는 서버의 SYN-ACK 패킷을 수신한 후, 연결이 성공적으로 설정되었다는 것을 알리기 위해 ACK 패킷을 서버에 보냅니다. 이 패킷은 ACK 플래그가 설정되어 있으며, 서버의 ISN에 대한 ACK 번호(2001)를 포함합니다.
   
   ```
   클라이언트 --> 서버 : ACK, ACK = 2001
   ```

이 과정을 통해 클라이언트와 서버는 서로의 초기 순서 번호를 확인하고, 안정적인 연결이 설정됩니다.

### TCP 4-Way Handshake

TCP의 연결 종료 과정인 4-way handshake는 클라이언트와 서버 간의 데이터 전송이 완료된 후 연결을 안전하게 종료하기 위해 사용됩니다. 이 과정은 다음과 같은 단계로 이루어집니다:

1. **FIN (Finish)**:
   - 클라이언트가 데이터 전송을 완료한 후, 연결 종료 요청을 서버에 보냅니다. 이 요청은 FIN 플래그가 설정된 TCP 세그먼트로, 클라이언트의 마지막 순서 번호를 포함합니다.
   
   ```
   클라이언트 --> 서버 : FIN
   ```

2. **ACK (Acknowledge)**:
   - 서버는 클라이언트의 FIN 패킷을 수신한 후, 연결 종료 요청을 수락하는 응답을 보냅니다. 이 응답은 ACK 플래그가 설정된 TCP 세그먼트로, 클라이언트의 FIN에 대한 ACK 번호를 포함합니다.
   
   ```
   서버 --> 클라이언트 : ACK
   ```

3. **FIN (Finish)**:
   - 서버가 자신의 데이터 전송을 완료한 후, 클라이언트에 연결 종료 요청을 보냅니다. 이 요청은 FIN 플래그가 설정된 TCP 세그먼트로, 서버의 마지막 순서 번호를 포함합니다.
   
   ```
   서버 --> 클라이언트 : FIN
   ```

4. **ACK (Acknowledge)**:
   - 클라이언트는 서버의 FIN 패킷을 수신한 후, 서버의 FIN에 대한 ACK 패킷을 서버에 보냅니다.
   
   ```
   클라이언트 --> 서버 : ACK
   ```

이 과정을 통해 클라이언트와 서버는 안전하게 연결을 종료하며, 데이터 손실 없이 모든 전송이 완료되었음을 확인합니다.

### 요약
- **3-way handshake**는 연결을 설정하기 위한 과정이며, 클라이언트와 서버 간에 서로의 초기 순서 번호를 확인합니다.
- **4-way handshake**는 연결을 종료하기 위한 과정으로, 클라이언트와 서버가 데이터 전송을 완료한 후 안정적으로 연결을 해제합니다.

이러한 핸드셰이크 과정 덕분에 TCP는 신뢰성 있는 데이터 전송을 보장합니다.


TCP의 3-way handshake는 연결 지향 프로토콜인 TCP에서 연결을 설정하는 과정으로, 각 클라이언트와 서버 간의 연결을 수립하는 데 사용됩니다. 일반적으로 TCP 연결은 IP 주소와 포트를 기반으로 하며, 특정 API와의 연결 설정을 위해 새로운 TCP 연결이 필요할 수 있습니다.

### 1. **API 호출과 TCP 연결**
- **각 API 호출마다 연결 생성**: 
  - 사용자가 API를 호출할 때마다 새로 TCP 연결을 설정하는 경우, 3-way handshake가 발생합니다. 예를 들어, 클라이언트가 특정 REST API를 호출하기 위해 서버와 연결을 설정할 때, 해당 연결은 API 호출마다 수립됩니다.
  
- **지속 연결**:
  - 반면, HTTP/1.1에서는 기본적으로 지속적인 연결(persistent connection)을 지원합니다. 이 경우, 클라이언트는 첫 번째 API 호출 후 연결을 유지하고 이후의 여러 API 호출에 대해 동일한 TCP 연결을 재사용할 수 있습니다. 이 경우 3-way handshake는 첫 번째 호출 시에만 발생하고, 이후의 호출에서는 이미 설정된 연결을 사용하게 됩니다.

### 2. **HTTP/2와 HTTP/3**
- **HTTP/2**: 
  - HTTP/2는 멀티플렉싱 기능을 제공하여, 단일 TCP 연결을 통해 여러 요청과 응답을 동시에 처리할 수 있습니다. 즉, 여러 API 호출이 동시에 이루어져도 하나의 TCP 연결을 통해 처리할 수 있습니다.
  
- **HTTP/3**: 
  - HTTP/3는 QUIC 프로토콜을 기반으로 하며, 연결 설정 및 데이터 전송 방식을 최적화하여 지연 시간을 줄이고, 보다 효율적인 데이터 전송을 가능하게 합니다.

### 3. **결론**
- 사용자가 API를 호출할 때마다 새로운 TCP 연결을 설정하면 3-way handshake가 필요합니다.
- 지속적인 연결을 사용하는 경우, 첫 번째 호출 시에만 3-way handshake가 발생하고 이후의 호출은 기존 연결을 재사용합니다.
- HTTP/2 및 HTTP/3와 같은 현대적인 프로토콜은 이러한 연결 설정 방식을 더욱 최적화하여 성능을 향상시킵니다.

따라서, 사용자의 API 호출마다 연결이 생성되는지는 사용하는 프로토콜과 연결 설정 방식에 따라 달라질 수 있습니다.

지속 연결(persistent connection)은 클라이언트와 서버 간의 TCP 연결을 여러 요청 및 응답에 대해 재사용하는 방법입니다. 이를 통해 성능을 향상시키고 지연 시간을 줄일 수 있습니다. 지속 연결을 조절하는 방법은 사용하는 프로토콜에 따라 다르며, HTTP/1.1과 HTTP/2의 경우를 살펴보겠습니다.

### 1. **HTTP/1.1의 지속 연결**
HTTP/1.1에서는 기본적으로 지속 연결이 활성화되어 있습니다. 하지만 클라이언트와 서버는 연결 유지 시간이나 최대 요청 수를 조절할 수 있는 몇 가지 헤더를 사용합니다.

- **Connection 헤더**:
  - 클라이언트가 요청 시 `Connection: keep-alive` 헤더를 포함하면, 서버는 해당 연결을 유지하도록 설정할 수 있습니다. 서버가 응답 시에도 이 헤더를 포함해야 합니다.
  
- **Keep-Alive 헤더**:
  - `Keep-Alive` 헤더를 통해 지속 연결의 시간과 요청 수를 조절할 수 있습니다.
    - **timeout**: 연결이 유지될 최대 시간(초)
    - **max**: 최대 요청 수
  - 예:
    ```
    Keep-Alive: timeout=5, max=100
    ```

- **서버 설정**:
  - 서버 측에서 지속 연결을 지원하도록 설정해야 합니다. 예를 들어, Apache나 Nginx와 같은 웹 서버에서는 설정 파일에서 지속 연결 관련 옵션을 활성화하거나 조절할 수 있습니다.

### 2. **HTTP/2의 지속 연결**
HTTP/2는 기본적으로 지속 연결을 사용하며, 멀티플렉싱을 통해 단일 TCP 연결에서 여러 요청과 응답을 동시에 처리할 수 있습니다. 이를 통해 지속 연결을 더 효율적으로 사용할 수 있습니다.

- **프레임 및 스트림**:
  - HTTP/2에서는 요청과 응답을 프레임으로 분할하고, 여러 스트림을 통해 동시에 처리할 수 있습니다. 클라이언트는 서버와의 연결을 유지하면서 여러 API 호출을 효율적으로 전송할 수 있습니다.

- **Flow Control**:
  - HTTP/2에서는 흐름 제어를 통해 데이터 전송을 조절할 수 있습니다. 이를 통해 서버와 클라이언트 간의 데이터 전송 속도를 조정하고, 네트워크 혼잡을 방지할 수 있습니다.

### 3. **Connection Pooling**
- **클라이언트 측에서의 연결 풀**:
  - 클라이언트는 여러 연결을 유지하기 위해 연결 풀을 사용할 수 있습니다. 이를 통해 연결을 재사용하여 성능을 최적화하고, 서버에 대한 요청을 더 빠르게 처리할 수 있습니다.

### 4. **타임아웃 조절**
- **서버와 클라이언트 설정**:
  - 지속 연결의 유효 기간은 서버와 클라이언트에서 설정할 수 있습니다. 서버에서 일정 시간 동안 요청이 없으면 연결을 종료하도록 설정하거나, 클라이언트에서 연결이 필요할 때만 요청을 보내도록 설정할 수 있습니다.

### 요약
- **HTTP/1.1**에서는 `Connection`과 `Keep-Alive` 헤더를 통해 지속 연결을 조절할 수 있습니다.
- **HTTP/2**는 기본적으로 지속 연결을 사용하며, 멀티플렉싱과 흐름 제어를 통해 더욱 효율적인 연결 관리를 제공합니다.
- **연결 풀**과 **타임아웃 조절**을 통해 성능을 최적화할 수 있습니다.

적절한 설정을 통해 지속 연결을 효과적으로 관리하면, 성능을 향상시키고 서버 리소스를 절약할 수 있습니다.